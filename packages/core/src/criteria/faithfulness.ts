import { z } from 'zod';
import { Judge } from '../eval-runner';
import { Criterion, CriterionEvaluationParams, CriterionResult } from './criterion';

type FaithfulnessCriterionResult = {
  results: { claim: string; supported: boolean }[];
};

export function faithfulnessCriterion(params: {
  judge: Judge;
  /** The threshold for the score to be considered successful. Number between 0 and 1.  Default is 1 */
  scoreThreshold?: number;
}): Criterion<FaithfulnessCriterionResult> {
  return {
    name: 'Faithfulness',

    async evaluate({
      messages,
    }: CriterionEvaluationParams): Promise<CriterionResult<FaithfulnessCriterionResult>> {
      const lastMessage = messages[messages.length - 1];
      const context = messages
        .slice(0, messages.length - 1)
        .map((m) => m.role + ': ' + m.content.toString())
        .join('\n\n');

      const {
        output: { claims },
      } = await params.judge.invoke({
        schema: z.object({ claims: z.array(z.string()) }),
        messages: [
          {
            role: 'system',
            content: `The following is text generated by AI. Your goal is to extract all factual claims made by the AI so that we can evaluate their correctness against the context that the AI was given. Extract the claims made by the AI accurately and regardless of whether they are correct or incorrect. The text is:\n\n"${lastMessage.content.toString()}"`,
          },
        ],
      });

      if (claims.length === 0) return { status: 'success', output: { results: [] } };

      const {
        output: { results },
      } = await params.judge.invoke({
        schema: z.object({
          results: z
            .object({
              clain_index: z.number(),
              supported: z.boolean(),
            })
            .array(),
        }),

        messages: [
          {
            role: 'system',
            content: `Verify claims against context.
          <context>
          ${context}
          </context>
  
          <Claims>
          ${claims.map((c, i) => `[Claim ${i}] : ${c}`).join('\n\n')}
          </Claims>`,
          },
        ],
      });

      const score = Math.floor(results.filter((r) => r.supported).length / results.length);

      return {
        reason: `${Math.floor(score * 100)}% of claims supported by context`,
        status: score > (params.scoreThreshold ?? 1) ? 'success' : 'failure',
        output: {
          results: results.map((r) => ({
            claim: claims[r.clain_index],
            supported: r.supported,
          })),
        },
      };
    },
  };
}
